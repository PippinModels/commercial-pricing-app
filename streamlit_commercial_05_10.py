# -*- coding: utf-8 -*-
"""Streamlit_Commercial_05_10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JXj1UBQlSjpRpjEUKDGeDjZuHDg4grDv
"""

import streamlit as st
import pandas as pd
import gspread
import json
from oauth2client.service_account import ServiceAccountCredentials
from bs4 import BeautifulSoup

# Google Sheets Auth
scope = ["https://spreadsheets.google.com/feeds", "https://www.googleapis.com/auth/drive"]
json_key = st.secrets["google_sheets"]["json_key"]
service_account_info = json.loads(json_key)
creds = ServiceAccountCredentials.from_json_keyfile_dict(service_account_info, scope)
client = gspread.authorize(creds)

spreadsheet_id = "1YYPoxD46Z0-_BrQhjdDPpU5sSDHwr62j72am5u7wjGE"
sheet = client.open_by_key(spreadsheet_id)
summary_sheet = sheet.worksheet("Summary Sheet")

# Load data
data = summary_sheet.get_all_records()
df = pd.DataFrame(data)

product_hierarchy = {
    "Update Search": 1, "Current Owner Search": 2, "Two Owner Search": 3,
    "Full 30 YR Search": 4, "Full 40 YR Search": 5, "Full 50 YR Search": 6,
    "Full 60 YR Search": 7, "Full 80 YR Search": 8, "Full 100 YR Search": 9,
}

st.title("Commercial Prediction Model (05/21/25)")
st.markdown("**Disclaimer:** Predicted pricing is based on a single parcel search.")

if not df.empty:
    mapped_type_options = list(df["Mapped Type"].unique()) + ["Other"]
    mapped_type = st.selectbox("Select Mapped Type", mapped_type_options)
    if mapped_type == "Other":
        mapped_type = st.text_input("Enter your Mapped Type:")

    available_products = df[df["Mapped Type"] == mapped_type]["Mapped Product Ordered"].unique().tolist()
    all_products = list(product_hierarchy.keys())
    missing_products = [p for p in all_products if p not in available_products]

    mapped_product = st.selectbox("Select Mapped Product Ordered", available_products + ["Other"])
    if mapped_product == "Other":
        mapped_product = st.text_input("Enter your Mapped Product Ordered:")

    online_offline = st.selectbox("Select Online/Offline", ["Online", "Offline"])

    filtered_df = df[
        (df["Mapped Type"] == mapped_type) &
        (df["Mapped Product Ordered"] == mapped_product) &
        (df["Offline/Online"] == online_offline)
    ]

    if missing_products:
        st.markdown("### Manual Entry for Missing Products")
        manual_entries = []
        for product in missing_products:
            for mode in ["Online", "Offline"]:
                filtered_check = df[
                    (df["Mapped Type"] == mapped_type) &
                    (df["Mapped Product Ordered"] == product) &
                    (df["Offline/Online"] == mode)
                ]
                if filtered_check.empty:
                    user_input = st.number_input(
                        f"Enter price for {product} ({mode})",
                        min_value=0.0,
                        format="%.2f",
                        key=f"manual_{product}_{mode}"
                    )
                    if user_input > 0:
                        manual_entries.append([mapped_type, product, mode, "New Manual Entry", "", user_input, "", pd.Timestamp.now().strftime("%Y-%m-%d")])

        if manual_entries:
            try:
                manual_sheet = sheet.worksheet("User Prediction Selections")
            except gspread.exceptions.WorksheetNotFound:
                manual_sheet = sheet.add_worksheet(title="User Prediction Selections", rows="1000", cols="20")
                manual_sheet.append_row([
                    "Mapped Type", "Mapped Product Ordered", "Offline/Online",
                    "Selection Label", "Selected Range", "Range Start", "Range End", "Timestamp"
                ])
            for row in manual_entries:
                manual_sheet.append_row(row)

    # Additional manual entry for any product/channel combination
    st.markdown("### Add Manual Entry for Any Product")
    selected_product = st.selectbox("Select Product to Add", list(product_hierarchy.keys()), key="add_product")
    selected_channel = st.selectbox("Select Channel", ["Online", "Offline"], key="add_channel")
    added_price = st.number_input("Enter Price", min_value=0.0, format="%.2f", key="add_price")
    if st.button("Add Manual Entry"):
        try:
            manual_sheet = sheet.worksheet("User Prediction Selections")
        except gspread.exceptions.WorksheetNotFound:
            manual_sheet = sheet.add_worksheet(title="User Prediction Selections", rows="1000", cols="20")
            manual_sheet.append_row([
                "Mapped Type", "Mapped Product Ordered", "Offline/Online",
                "Selection Label", "Selected Range", "Range Start", "Range End", "Timestamp"
            ])
        existing_entries = manual_sheet.get_all_records()
        is_duplicate = any(
            row["Mapped Type"] == mapped_type and
            row["Mapped Product Ordered"] == selected_product and
            row["Offline/Online"] == selected_channel and
            row["Selection Label"] == "New Manual Entry"
            for row in existing_entries
        )
        if is_duplicate:
            st.warning("This manual entry already exists.")
        else:
            manual_sheet.append_row([
                mapped_type, selected_product, selected_channel,
                "New Manual Entry", "", added_price, "", pd.Timestamp.now().strftime("%Y-%m-%d")
            ])
            st.success("Manual entry added successfully.")
            st.success("Manual entry added successfully.")

    if not filtered_df.empty:
            row = filtered_df.iloc[0]

            adjusted_mean = row["Adjusted Forecasted Pricing (mean)"]
            adjusted_median = row["Adjusted Forecasted Pricing (median)"]
            smoothed_mean = row["Smoothed Forecasted Pricing (mean)"]
            smoothed_median = row["Smoothed Forecasted Pricing (median)"]
            predicted_mean = row.get("Predicted Forecasted Pricing (mean)")
            predicted_median = row.get("Predicted Forecasted Pricing (median)")

            prediction_options = {
                "A.": ("Adjusted Mean – Smoothed Mean", sorted([adjusted_mean, smoothed_mean])),
                "B.": ("Adjusted Median – Smoothed Median", sorted([adjusted_median, smoothed_median])),
                "C.": ("Adjusted Mean – Adjusted Median", sorted([adjusted_mean, adjusted_median])),
                "D.": ("Smoothed Mean – Smoothed Median", sorted([smoothed_mean, smoothed_median])),
            }

            if predicted_mean is not None and predicted_median is not None:
                prediction_options["E."] = ("Predicted Mean – Predicted Median", sorted([predicted_mean, predicted_median]))

            formatted_options = {}
            seen_ranges = set()

            for label, (desc, values) in prediction_options.items():
                lo, hi = [int(-(-x // 5) * 5) for x in values]
                range_key = (lo, hi)
                if range_key not in seen_ranges:
                    seen_ranges.add(range_key)
                    option_text = f"${lo:,} – ${hi:,}"
                    formatted_options[option_text] = (label, desc, lo, hi)

            st.session_state.prediction_choices = formatted_options
            st.session_state.selection_made = False
            st.session_state.selected_entry = None

if "prediction_choices" in st.session_state:
    st.subheader("Select Closest Price Range")
    st.markdown("<style>div.row-widget.stRadio > div{flex-direction: column;}</style>", unsafe_allow_html=True)
    selected_text = st.radio(
        "Choose range:",
        options=list(st.session_state.prediction_choices.keys()) + ["Other (Enter manually)"],
        index=None,
        label_visibility="collapsed"
    )

    if selected_text:
        if selected_text == "Other (Enter manually)":
            manual_entry = st.number_input("Enter your own predicted value:", min_value=0.0, format="%.2f")
            st.session_state.selection_made = True
            st.session_state.selected_entry = ("Manual", "Manual Entry", manual_entry, '')
        else:
            st.session_state.selection_made = True
            st.session_state.selected_entry = st.session_state.prediction_choices[selected_text]
            st.success(f"You selected: {selected_text}")

if st.session_state.get("selection_made", False) and st.button("Submit to Sheet"):
    label, desc, lo, hi = st.session_state.selected_entry
    timestamp = pd.Timestamp.now().strftime("%Y-%m-%d")
    sheet_name = "User Prediction Selections"

    try:
        try:
            submission_sheet = sheet.worksheet(sheet_name)
        except gspread.exceptions.WorksheetNotFound:
            submission_sheet = sheet.add_worksheet(title=sheet_name, rows="1000", cols="20")
            submission_sheet.append_row([
                "Mapped Type", "Mapped Product Ordered", "Offline/Online",
                "Selection Label", "Selected Range", "Range Start", "Range End", "Timestamp"
            ])

        existing = submission_sheet.get_all_records()
        duplicate = any(
            row["Mapped Type"] == mapped_type and
            row["Mapped Product Ordered"] == mapped_product and
            row["Offline/Online"] == online_offline and
            row["Selection Label"] == label
            for row in existing
        )

        if duplicate:
            st.warning("You've already submitted this selection.")
        else:
            submission_sheet.append_row([
                mapped_type, mapped_product, online_offline,
                label,
                desc,
                int(manual_entry) if label == "Manual Entry" else int(lo),
                '' if label == "Manual Entry" else int(hi),
                timestamp
            ])
            st.success("Your selected range has been recorded.")
            st.markdown("**Disclaimer:** Predicted pricing is based on a single parcel search.")
    except Exception as e:
        st.error(f"Failed to record selection: {e}")
